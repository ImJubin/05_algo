
'''
문제 복기:
N×N 크기의 격자판이 있다.

격자의 각 칸에는 정수가 하나씩 적혀 있다.

공은 어떤 칸에서 시작해서 상하좌우로 이동할 수 있다.

단, 이동할 수 있는 조건은 현재 칸보다 숫자가 작은 칸으로만 이동 가능하다.

이동할 때마다 공은 한 칸씩 이동하며, 이동할 수 있을 때까지 계속 이동한다.

가장 많이 이동할 수 있는 경우의 이동 횟수를 구하는 문제다.
(정확히는, 출발칸을 포함한 "이동한 칸의 수"를 세는 것)

정리하면:
"어디서 출발하면 가장 많이 이동할 수 있는지 찾고, 그 최대 이동 수를 구하는 문제"

시작할 때 i, j칸에서 출발해서,

매번 인접한 칸(상, 하, 좌, 우) 중 자기보다 작은 값이 있으면 그쪽으로 이동

이동을 반복하다가 더 이상 갈 곳이 없으면 이동을 멈춘다

출발할 수 있는 모든 칸을 다 시도해서, 그중 가장 많은 이동 수를 찾는 문제

핵심 요소:
상하좌우 이동 (dir 방향 정의)

이동은 현재보다 작은 수가 있는 칸으로만 가능

이동할 때마다 이동 칸 수(plus)를 세기

모든 칸에 대해 시작해서 최대 이동 길이를 구한다


3
5
19 57 74 73 94
26 27 32 98 61
40 88 49 38 25
21 66 53 95 46
80 23 58 39 89
7
40 49 56 83 84 31 11
42 95 12 16 21 19 26
98 93 29 68 10 92 82
23 13 24 58 35 25 47
17 66 39 67 70 14 87
22 34 46 94 69 96 89
62 88 50 51 61 71 86
9
90 57 65 18 25 93 64 11 54
95 19 80 37 63 44 15 14 10
89 59 46 70 38 36 21 51 97
53 47 60 88 40 48 79 56 55
83 13 27 86 45 71 75 28 84
30 20 29 35 99 98 61 94 23
85 42 43 22 16 77

'''

# dir 방향 정의
dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

T = int(input())
for tc in range(1, T+1):
    N = int(input())
    ball = [list(map(int, input().split())) for _ in range(N)]
    cnt_list = []
    #시작위치 저장
    for i in range(N):
        for j in range(N):
            start = ball[i][j]
            r = i
            c = j 
            count = 1 # 1 부터 시작 !!!
            while True:
                min_val = float('inf')
            #사방탐색 시작
                for dir in range(4):
                    nr = r + dr[dir]
                    nc = c + dc[dir]
                    #최솟값찾아서
                    if 0<=nr<N and 0<=nc<N:
                        if ball[nr][nc] < ball[r][c]:
                            if ball[nr][nc]< min_val:
                                min_val = ball[nr][nc]
                                next_r = nr
                                next_c = nc
                #그쪽으로 이동
                if min_val < ball[r][c]:
                    r = next_r
                    c = next_c
                    count += 1    #한칸이동 기록
                else:
                    break
            counts.append(count)
        
    ans = max(counts)

    print(f'#{tc} {ans}')